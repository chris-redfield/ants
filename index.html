<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ant Colony Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow: auto;
        }

        body {
            background: #1a1a2e;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: stretch; /* Changed from center to allow proper scrolling */
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #e0e0e0;
            overflow: auto;
        }

        header {
            padding: 15px 20px;
            text-align: center;
            background: linear-gradient(180deg, #1a1a2e 0%, transparent 100%);
            width: 100%;
            z-index: 10;
            align-self: stretch;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 300;
            letter-spacing: 3px;
            color: #f4a261;
            text-transform: uppercase;
        }

        .subtitle {
            font-size: 0.75rem;
            color: #888;
            margin-top: 5px;
            letter-spacing: 1px;
        }

        #game-container {
            position: relative;
            flex: 1;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
            width: 100%;
            padding: 20px;
        }

        #canvas-wrapper {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(244, 162, 97, 0.1);
            flex-shrink: 0;
            margin: auto; /* Center when smaller than viewport, align to start when larger */
        }

        canvas {
            display: block;
        }

        #bg-canvas {
            background: #2d5a27;
        }

        #pheromone-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 2;
        }

        #ant-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 3;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            z-index: 100;
            padding: 15px 20px;
            background: rgba(26, 26, 46, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(244, 162, 97, 0.2);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button {
            padding: 10px 20px;
            font-size: 0.85rem;
            border: 1px solid rgba(244, 162, 97, 0.3);
            border-radius: 6px;
            background: rgba(244, 162, 97, 0.1);
            color: #f4a261;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        button:hover {
            background: rgba(244, 162, 97, 0.2);
            border-color: #f4a261;
        }

        button:active {
            transform: scale(0.95);
        }

        button.active {
            background: rgba(244, 162, 97, 0.3);
            border-color: #f4a261;
        }

        input[type="range"] {
            width: 100px;
            accent-color: #f4a261;
        }

        .stats {
            position: fixed;
            top: 70px;
            left: 20px;
            font-size: 0.75rem;
            color: #666;
            line-height: 1.8;
            z-index: 100;
        }

        .stats span {
            color: #f4a261;
        }

        .legend {
            position: fixed;
            top: 70px;
            right: 20px;
            font-size: 0.7rem;
            color: #666;
            line-height: 2;
            z-index: 100;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .instructions {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: #555;
            text-align: center;
            z-index: 50;
        }

        /* Menu styles */
        #menu-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            text-align: center;
            width: 100%;
        }

        .menu-title {
            font-size: 3rem;
            font-weight: 300;
            letter-spacing: 5px;
            color: #f4a261;
            margin-bottom: 10px;
        }

        .menu-subtitle {
            font-size: 1rem;
            color: #888;
            margin-bottom: 40px;
            letter-spacing: 2px;
        }

        .menu-options {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
        }

        .mode-btn {
            padding: 15px 30px;
            font-size: 1rem;
            border: 2px solid rgba(244, 162, 97, 0.3);
            border-radius: 8px;
            background: rgba(244, 162, 97, 0.1);
            color: #ccc;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-btn:hover {
            background: rgba(244, 162, 97, 0.2);
            border-color: rgba(244, 162, 97, 0.5);
        }

        .mode-btn.active {
            background: rgba(244, 162, 97, 0.3);
            border-color: #f4a261;
            color: #f4a261;
        }

        #colony-selector {
            margin-bottom: 30px;
        }

        #colony-selector label {
            display: block;
            color: #888;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .colony-count-btns {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .count-btn {
            width: 50px;
            height: 50px;
            font-size: 1.2rem;
            border: 2px solid rgba(244, 162, 97, 0.3);
            border-radius: 50%;
            background: rgba(244, 162, 97, 0.1);
            color: #ccc;
            cursor: pointer;
            transition: all 0.3s;
        }

        .count-btn:hover {
            background: rgba(244, 162, 97, 0.2);
        }

        .count-btn.active {
            background: rgba(244, 162, 97, 0.3);
            border-color: #f4a261;
            color: #f4a261;
        }

        .start-btn {
            padding: 18px 50px;
            font-size: 1.2rem;
            border: 2px solid #f4a261;
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(244, 162, 97, 0.3), rgba(244, 162, 97, 0.1));
            color: #f4a261;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            letter-spacing: 1px;
        }

        .start-btn:hover {
            background: linear-gradient(135deg, rgba(244, 162, 97, 0.5), rgba(244, 162, 97, 0.2));
            transform: scale(1.02);
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 600px) {
            header {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.2rem;
            }

            .controls {
                bottom: 10px;
                padding: 10px 15px;
                gap: 8px;
            }

            button {
                padding: 8px 14px;
                font-size: 0.75rem;
            }

            input[type="range"] {
                width: 80px;
            }

            .stats, .legend {
                font-size: 0.65rem;
            }

            .instructions {
                bottom: 85px;
                font-size: 0.65rem;
            }
        }
    </style>
</head>
<body>
    <!-- Menu Screen -->
    <div id="menu-screen">
        <h1 class="menu-title">üêú Ant Colony</h1>

        <div class="menu-options">
            <button id="single-mode-btn" class="mode-btn active">Single Colony</button>
            <button id="multi-mode-btn" class="mode-btn">Multiple Colonies</button>
        </div>

        <div id="colony-selector" class="hidden">
            <label>Number of Colonies:</label>
            <div class="colony-count-btns">
                <button class="count-btn active" data-count="2">2</button>
                <button class="count-btn" data-count="3">3</button>
                <button class="count-btn" data-count="4">4</button>
            </div>
        </div>

        <button id="start-btn" class="start-btn">Start Simulation</button>
    </div>

    <header id="game-header" class="hidden">
        <h1>üêú Ant Colony</h1>
    </header>

    <div id="game-container" class="hidden">
        <div id="canvas-wrapper">
            <canvas id="bg-canvas"></canvas>
            <canvas id="pheromone-canvas"></canvas>
            <canvas id="ant-canvas"></canvas>
        </div>
    </div>

    <div id="stats" class="stats hidden">
        <div>FPS: <span id="fps-counter">0</span></div>
        <div>Ants: <span id="ant-count">0</span></div>
        <div>Food Collected: <span id="food-collected">0</span></div>
        <div>Food Sources: <span id="food-sources">0</span></div>
        <div>Colony Size: <span id="colony-size">1</span></div>
    </div>

    <div id="legend" class="legend hidden">
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, #b08860, #6b4423);"></div>
            <span>Ant Hill</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(135deg, #4ade80, #fbbf24, #f87171);"></div>
            <span>Food</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(77, 166, 255, 0.5);"></div>
            <span>Home Trail</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(255, 180, 50, 0.5);"></div>
            <span>Food Trail</span>
        </div>
    </div>

    <div id="instructions" class="instructions hidden">Click to add food ‚Ä¢ Watch trails emerge</div>

    <div id="controls" class="controls hidden">
        <div class="control-group">
            <label>Ants</label>
            <input type="range" id="ant-slider" min="20" max="500" value="150">
        </div>
        <div class="control-group">
            <label>Speed</label>
            <input type="range" id="speed-slider" min="1" max="5" value="2">
        </div>
        <div class="control-group">
            <label>Food</label>
            <input type="range" id="food-slider" min="0" max="15" value="5">
        </div>
        <div class="control-group">
            <label>Trails</label>
            <button id="toggle-trails" class="active">On</button>
        </div>
        <div class="control-group">
            <label>Style</label>
            <button id="toggle-style" class="active">Ant</button>
        </div>
        <div class="control-group">
            <label>Reset</label>
            <button id="reset-btn">‚Ü∫</button>
        </div>
    </div>

    <script>
        // Canvas setup
        const bgCanvas = document.getElementById('bg-canvas');
        const pheromoneCanvas = document.getElementById('pheromone-canvas');
        const antCanvas = document.getElementById('ant-canvas');
        const bgCtx = bgCanvas.getContext('2d');
        const pheromoneCtx = pheromoneCanvas.getContext('2d');
        const antCtx = antCanvas.getContext('2d');

        // Size configuration
        let width, height;
        const CELL_SIZE = 4; // Pheromone grid cell size
        let gridWidth, gridHeight;

        // Game mode
        let gameMode = 'single'; // 'single' or 'multi'
        let colonyCount = 2; // 2-4 colonies in multi mode

        // Colony colors
        const COLONY_COLORS = [
            { main: '#f4a261', light: '#f4b982', dark: '#c4824a', trail: [255, 180, 100] },  // Orange
            { main: '#4da6ff', light: '#7dbfff', dark: '#2d86df', trail: [77, 166, 255] },   // Blue
            { main: '#4ade80', light: '#7aeea0', dark: '#2abe60', trail: [74, 222, 128] },  // Green
            { main: '#a78bfa', light: '#c7abff', dark: '#876bda', trail: [167, 139, 250] }   // Purple
        ];

        // Simulation state
        let ants = [];
        let foods = [];
        let colonies = []; // Array of colony objects
        let colony = null; // Reference to colonies[0] for single mode compatibility
        let showTrails = true;
        let simulationSpeed = 2;
        let targetAntCount = 150;
        let targetFoodCount = 5;
        let antStyle = 'classic'; // 'classic' or 'detailed'

        // Constants
        const ANT_SPEED = 2;
        const PHEROMONE_DEPOSIT = 100;
        const PHEROMONE_DECAY = 0.995;
        const PHEROMONE_DIFFUSE = 0.1;
        const WANDER_STRENGTH = 0.3;
        const PHEROMONE_FOLLOW_STRENGTH = 0.8;

        // FPS tracking
        let frameCount = 0;
        let lastFpsTime = performance.now();
        let currentFps = 0;

        // Track device pixel ratio to detect browser zoom
        let lastDevicePixelRatio = window.devicePixelRatio;

        function resize(preserveState = false) {
            const container = document.getElementById('game-container');
            // Use most of the available space - no artificial cap
            const maxWidth = container.clientWidth - 40;
            const maxHeight = container.clientHeight - 40;

            const newWidth = Math.floor(maxWidth / CELL_SIZE) * CELL_SIZE;
            const newHeight = Math.floor(maxHeight / CELL_SIZE) * CELL_SIZE;

            const newGridWidth = Math.floor(newWidth / CELL_SIZE);
            const newGridHeight = Math.floor(newHeight / CELL_SIZE);

            // Check if grid size actually changed
            const gridSizeChanged = newGridWidth !== gridWidth || newGridHeight !== gridHeight;
            const oldGridWidth = gridWidth;
            const oldGridHeight = gridHeight;

            width = newWidth;
            height = newHeight;
            gridWidth = newGridWidth;
            gridHeight = newGridHeight;

            [bgCanvas, pheromoneCanvas, antCanvas].forEach(canvas => {
                canvas.width = width;
                canvas.height = height;
            });

            // Set explicit size on canvas wrapper to prevent shrinking on zoom
            const wrapper = document.getElementById('canvas-wrapper');
            wrapper.style.width = width + 'px';
            wrapper.style.height = height + 'px';

            if (gridSizeChanged && colonies.length > 0) {
                // Resize pheromone grids for each colony
                for (const col of colonies) {
                    const oldHome = col.homePheromones;
                    const oldFood = col.foodPheromones;
                    col.homePheromones = new Float32Array(gridWidth * gridHeight);
                    col.foodPheromones = new Float32Array(gridWidth * gridHeight);

                    // Copy old pheromone data if preserving state
                    if (preserveState && oldHome) {
                        const minWidth = Math.min(oldGridWidth, gridWidth);
                        const minHeight = Math.min(oldGridHeight, gridHeight);
                        for (let y = 0; y < minHeight; y++) {
                            for (let x = 0; x < minWidth; x++) {
                                const oldIdx = y * oldGridWidth + x;
                                const newIdx = y * gridWidth + x;
                                col.homePheromones[newIdx] = oldHome[oldIdx];
                                col.foodPheromones[newIdx] = oldFood[oldIdx];
                            }
                        }
                    }
                }

                // Reinitialize offscreen canvas for new grid size
                initPheromoneOffscreen();
            }

            drawBackground();
        }

        function drawBackground() {
            // Base grass color
            bgCtx.fillStyle = '#2d5a27';
            bgCtx.fillRect(0, 0, width, height);

            // Add grass texture - random darker/lighter patches
            for (let i = 0; i < 500; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const size = 2 + Math.random() * 8;
                const brightness = Math.random();
                
                if (brightness > 0.5) {
                    bgCtx.fillStyle = `rgba(60, 120, 50, ${0.1 + Math.random() * 0.2})`;
                } else {
                    bgCtx.fillStyle = `rgba(20, 60, 15, ${0.1 + Math.random() * 0.2})`;
                }
                bgCtx.beginPath();
                bgCtx.ellipse(x, y, size, size * 0.6, Math.random() * Math.PI, 0, Math.PI * 2);
                bgCtx.fill();
            }

            // Add some grass blade hints
            bgCtx.strokeStyle = 'rgba(45, 100, 35, 0.3)';
            bgCtx.lineWidth = 1;
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const length = 5 + Math.random() * 10;
                const angle = -Math.PI/2 + (Math.random() - 0.5) * 0.5;
                
                bgCtx.beginPath();
                bgCtx.moveTo(x, y);
                bgCtx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                bgCtx.stroke();
            }
        }

        class Ant {
            constructor(x, y, colonyId = 0) {
                this.x = x;
                this.y = y;
                this.colonyId = colonyId;
                this.angle = Math.random() * Math.PI * 2;
                this.hasFood = false;
                this.foodColor = null; // Color of food being carried
                this.pheromoneTimer = 0;
                this.wanderAngle = 0;
                this.distanceTraveled = 0;
                this.maxPheromoneStrength = PHEROMONE_DEPOSIT;
            }

            getColony() {
                return colonies[this.colonyId];
            }

            update() {
                const myColony = this.getColony();

                // Deposit pheromones
                this.pheromoneTimer++;
                if (this.pheromoneTimer > 2) {
                    this.pheromoneTimer = 0;
                    const gx = Math.floor(this.x / CELL_SIZE);
                    const gy = Math.floor(this.y / CELL_SIZE);
                    if (gx >= 0 && gx < gridWidth && gy >= 0 && gy < gridHeight) {
                        const idx = gy * gridWidth + gx;
                        const strength = Math.max(10, this.maxPheromoneStrength - this.distanceTraveled * 0.3);
                        if (this.hasFood) {
                            // Returning: leave food trail so others can find the food
                            myColony.foodPheromones[idx] = Math.min(myColony.foodPheromones[idx] + strength, 255);
                        } else {
                            // Searching: leave home trail so we can find our way back
                            const distToColony = Math.sqrt((this.x - myColony.x) ** 2 + (this.y - myColony.y) ** 2);
                            const homeStrength = Math.max(20, PHEROMONE_DEPOSIT * 1.5 - distToColony * 0.2);
                            myColony.homePheromones[idx] = Math.min(myColony.homePheromones[idx] + homeStrength, 255);
                        }
                    }
                }

                if (this.hasFood) {
                    // ===== RETURNING STATE: Go directly to colony =====
                    const dx = myColony.x - this.x;
                    const dy = myColony.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Reached colony - drop food
                    if (dist < myColony.radius + 5) {
                        this.hasFood = false;
                        this.foodColor = null; // Clear the food color
                        myColony.foodStored++;
                        // Turn around to go search again
                        this.angle += Math.PI + (Math.random() - 0.5) * 1.0;
                        this.distanceTraveled = 0;
                        this.maxPheromoneStrength = PHEROMONE_DEPOSIT;
                    } else {
                        // Head towards colony with slight wandering for natural movement
                        const targetAngle = Math.atan2(dy, dx);
                        let angleDiff = targetAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                        // Strong homing - turn towards colony
                        this.angle += angleDiff * 0.2;

                        // Add tiny bit of wander for natural look
                        this.angle += (Math.random() - 0.5) * 0.1;
                    }
                } else {
                    // ===== SEARCHING STATE: Look for food using pheromones =====

                    // Check for food first
                    for (let food of foods) {
                        const dx = food.x - this.x;
                        const dy = food.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < food.radius * 0.7 && food.amount > 0) {
                            // Found food! Pick it up and switch to RETURNING state
                            this.hasFood = true;
                            this.foodColor = food.color; // Store the food's color
                            food.amount--;
                            // Point towards colony
                            this.angle = Math.atan2(myColony.y - this.y, myColony.x - this.x);
                            this.distanceTraveled = 0;
                            this.maxPheromoneStrength = PHEROMONE_DEPOSIT;
                            break;
                        }
                    }

                    // If didn't find food, follow food pheromones or wander
                    if (!this.hasFood) {
                        const senseAngle = Math.PI / 4;
                        const senseDistance = 12;

                        const leftStrength = this.sensePheromone(myColony.foodPheromones, this.angle - senseAngle, senseDistance);
                        const centerStrength = this.sensePheromone(myColony.foodPheromones, this.angle, senseDistance);
                        const rightStrength = this.sensePheromone(myColony.foodPheromones, this.angle + senseAngle, senseDistance);

                        const maxStrength = Math.max(leftStrength, centerStrength, rightStrength);

                        if (maxStrength > 2) {
                            // Follow food pheromones
                            if (centerStrength >= leftStrength && centerStrength >= rightStrength) {
                                this.wanderAngle += (Math.random() - 0.5) * WANDER_STRENGTH * 0.5;
                            } else if (leftStrength > rightStrength) {
                                this.wanderAngle -= PHEROMONE_FOLLOW_STRENGTH;
                            } else {
                                this.wanderAngle += PHEROMONE_FOLLOW_STRENGTH;
                            }
                        } else {
                            // No pheromones - random exploration
                            this.wanderAngle += (Math.random() - 0.5) * WANDER_STRENGTH * 2;
                        }

                        this.wanderAngle *= 0.9;
                        this.angle += this.wanderAngle * 0.1;
                    }
                }

                // Move
                const speed = ANT_SPEED;
                this.x += Math.cos(this.angle) * speed;
                this.y += Math.sin(this.angle) * speed;
                this.distanceTraveled += speed;

                // Bounce off walls
                const margin = 8;
                if (this.x < margin) { 
                    this.x = margin; 
                    this.angle = Math.PI - this.angle + (Math.random() - 0.5) * 0.5;
                    this.wanderAngle = 0;
                }
                if (this.x > width - margin) { 
                    this.x = width - margin; 
                    this.angle = Math.PI - this.angle + (Math.random() - 0.5) * 0.5;
                    this.wanderAngle = 0;
                }
                if (this.y < margin) { 
                    this.y = margin; 
                    this.angle = -this.angle + (Math.random() - 0.5) * 0.5;
                    this.wanderAngle = 0;
                }
                if (this.y > height - margin) { 
                    this.y = height - margin; 
                    this.angle = -this.angle + (Math.random() - 0.5) * 0.5;
                    this.wanderAngle = 0;
                }
            }

            sensePheromone(pheromones, angle, distance) {
                let total = 0;
                for (let d = 4; d <= distance; d += 4) {
                    const sx = this.x + Math.cos(angle) * d;
                    const sy = this.y + Math.sin(angle) * d;
                    const gx = Math.floor(sx / CELL_SIZE);
                    const gy = Math.floor(sy / CELL_SIZE);
                    if (gx >= 0 && gx < gridWidth && gy >= 0 && gy < gridHeight) {
                        total += pheromones[gy * gridWidth + gx];
                    }
                }
                return total;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Get colony color (use dark variant for ant body)
                const colonyColor = COLONY_COLORS[this.colonyId] || COLONY_COLORS[0];
                const antColor = gameMode === 'multi' ? colonyColor.dark : '#5c4033';

                if (antStyle === 'classic') {
                    // Classic simple ant
                    ctx.fillStyle = antColor;

                    // Body (single oval)
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 5, 3, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Head
                    ctx.beginPath();
                    ctx.arc(5, 0, 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Food being carried
                    if (this.hasFood) {
                        ctx.fillStyle = this.foodColor || '#4ade80';
                        ctx.beginPath();
                        ctx.arc(-5, 0, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // Detailed termite-style
                    const detailedColor = gameMode === 'multi' ? colonyColor.dark : '#3d2817';

                    // Legs
                    ctx.strokeStyle = detailedColor;
                    ctx.lineWidth = 0.8;
                    const legWiggle = Math.sin(this.distanceTraveled * 0.5) * 0.2;

                    // 3 pairs of legs
                    for (let i = -1; i <= 1; i++) {
                        const legX = i * 2;
                        const wiggle = (i === 0) ? 0 : legWiggle * i;

                        // Left leg
                        ctx.beginPath();
                        ctx.moveTo(legX, 0);
                        ctx.lineTo(legX - 3, -3 + wiggle);
                        ctx.stroke();

                        // Right leg
                        ctx.beginPath();
                        ctx.moveTo(legX, 0);
                        ctx.lineTo(legX - 3, 3 - wiggle);
                        ctx.stroke();
                    }

                    ctx.fillStyle = detailedColor;

                    // Abdomen (back)
                    ctx.beginPath();
                    ctx.ellipse(-3, 0, 3, 2.2, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Thorax (middle)
                    ctx.beginPath();
                    ctx.ellipse(1, 0, 2, 1.5, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Head
                    ctx.beginPath();
                    ctx.ellipse(4, 0, 1.8, 1.5, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Antennae
                    ctx.strokeStyle = detailedColor;
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(5, -0.5);
                    ctx.quadraticCurveTo(7, -2, 8, -1);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(5, 0.5);
                    ctx.quadraticCurveTo(7, 2, 8, 1);
                    ctx.stroke();

                    // Food being carried
                    if (this.hasFood) {
                        const foodCol = this.foodColor || '#4ade80';
                        ctx.fillStyle = foodCol;
                        ctx.beginPath();
                        ctx.arc(-6, 0, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            }
        }

        function createFood(x, y) {
            // Random number of sides (3-8) for organic shapes
            const sides = 3 + Math.floor(Math.random() * 6);
            const baseRadius = 12 + Math.random() * 12;
            
            // Generate irregular polygon vertices
            const vertices = [];
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                // Randomize radius for each vertex for organic look
                const r = baseRadius * (0.7 + Math.random() * 0.6);
                vertices.push({
                    x: Math.cos(angle) * r,
                    y: Math.sin(angle) * r
                });
            }
            
            // Random food color variations (different food types)
            const foodTypes = [
                { color: '#4ade80', highlight: '#86efac', name: 'leaf' },      // Green leaf
                { color: '#fbbf24', highlight: '#fcd34d', name: 'seed' },      // Yellow seed
                { color: '#f87171', highlight: '#fca5a5', name: 'berry' },     // Red berry
                { color: '#a78bfa', highlight: '#c4b5fd', name: 'flower' },    // Purple flower
                { color: '#fb923c', highlight: '#fdba74', name: 'crumb' },     // Orange crumb
            ];
            const foodType = foodTypes[Math.floor(Math.random() * foodTypes.length)];
            
            foods.push({
                x: x,
                y: y,
                radius: baseRadius,
                vertices: vertices,
                sides: sides,
                amount: 20 + Math.floor(Math.random() * 40),
                maxAmount: 60,
                color: foodType.color,
                highlight: foodType.highlight,
                rotation: Math.random() * Math.PI * 2
            });
        }

        function spawnRandomFood() {
            const margin = 80;
            let x, y;
            let attempts = 0;
            let tooClose;
            do {
                x = margin + Math.random() * (width - margin * 2);
                y = margin + Math.random() * (height - margin * 2);
                attempts++;
                // Check distance from all colonies
                tooClose = colonies.some(c => Math.sqrt((x - c.x) ** 2 + (y - c.y) ** 2) < 100);
            } while (tooClose && attempts < 20);

            createFood(x, y);
        }

        function createColony(id, x, y) {
            const colonyObj = {
                id: id,
                x: x,
                y: y,
                radius: 25,
                foodStored: 0,
                color: COLONY_COLORS[id],
                homePheromones: new Float32Array(gridWidth * gridHeight),
                foodPheromones: new Float32Array(gridWidth * gridHeight),
                granules: []
            };

            // Generate dirt granules for this colony
            const hillRadius = colonyObj.radius * 1.8;
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * hillRadius * 0.8;
                colonyObj.granules.push({
                    x: Math.cos(angle) * dist,
                    y: Math.sin(angle) * dist * 0.7 - 5,
                    size: 1 + Math.random() * 2,
                    brightness: Math.random()
                });
            }

            return colonyObj;
        }

        function init() {
            resize();

            // Create colonies
            colonies = [];
            const numColonies = gameMode === 'multi' ? colonyCount : 1;

            if (gameMode === 'single') {
                // Single colony in center
                colonies.push(createColony(0, width / 2, height / 2));
            } else {
                // Multiple colonies spread out
                const positions = [
                    { x: width * 0.25, y: height * 0.25 },  // Top-left
                    { x: width * 0.75, y: height * 0.75 },  // Bottom-right
                    { x: width * 0.75, y: height * 0.25 },  // Top-right
                    { x: width * 0.25, y: height * 0.75 }   // Bottom-left
                ];
                for (let i = 0; i < numColonies; i++) {
                    colonies.push(createColony(i, positions[i].x, positions[i].y));
                }
            }

            // Reference to first colony for backward compatibility
            colony = colonies[0];

            // Create initial ants for each colony
            ants = [];
            const antsPerColony = Math.floor(targetAntCount / numColonies);
            for (let c = 0; c < numColonies; c++) {
                const col = colonies[c];
                for (let i = 0; i < antsPerColony; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * col.radius;
                    ants.push(new Ant(
                        col.x + Math.cos(angle) * dist,
                        col.y + Math.sin(angle) * dist,
                        c
                    ));
                }
            }

            // Create initial food sources
            foods = [];
            const foodCount = gameMode === 'multi' ? targetFoodCount * 2 : targetFoodCount;
            for (let i = 0; i < foodCount; i++) {
                spawnRandomFood();
            }
        }

        // Helper function to update a single pheromone grid
        function updatePheromoneGrid(oldGrid, decay) {
            const newGrid = new Float32Array(gridWidth * gridHeight);
            const DIFFUSE_SELF = 1 - PHEROMONE_DIFFUSE;
            const DIFFUSE_NEIGHBOR = PHEROMONE_DIFFUSE / 8;

            for (let y = 0; y < gridHeight; y++) {
                const rowOffset = y * gridWidth;
                const rowAbove = (y > 0) ? (y - 1) * gridWidth : -1;
                const rowBelow = (y < gridHeight - 1) ? (y + 1) * gridWidth : -1;

                for (let x = 0; x < gridWidth; x++) {
                    const idx = rowOffset + x;
                    let sum = oldGrid[idx] * DIFFUSE_SELF;

                    const hasLeft = x > 0;
                    const hasRight = x < gridWidth - 1;

                    if (rowAbove >= 0) {
                        if (hasLeft) sum += oldGrid[rowAbove + x - 1] * DIFFUSE_NEIGHBOR;
                        sum += oldGrid[rowAbove + x] * DIFFUSE_NEIGHBOR;
                        if (hasRight) sum += oldGrid[rowAbove + x + 1] * DIFFUSE_NEIGHBOR;
                    }
                    if (hasLeft) sum += oldGrid[rowOffset + x - 1] * DIFFUSE_NEIGHBOR;
                    if (hasRight) sum += oldGrid[rowOffset + x + 1] * DIFFUSE_NEIGHBOR;
                    if (rowBelow >= 0) {
                        if (hasLeft) sum += oldGrid[rowBelow + x - 1] * DIFFUSE_NEIGHBOR;
                        sum += oldGrid[rowBelow + x] * DIFFUSE_NEIGHBOR;
                        if (hasRight) sum += oldGrid[rowBelow + x + 1] * DIFFUSE_NEIGHBOR;
                    }

                    newGrid[idx] = sum * decay;
                }
            }
            return newGrid;
        }

        function updatePheromones() {
            const HOME_DECAY = 0.998;
            const FOOD_DECAY = 0.994;

            // Update pheromones for each colony
            for (const col of colonies) {
                col.homePheromones = updatePheromoneGrid(col.homePheromones, HOME_DECAY);
                col.foodPheromones = updatePheromoneGrid(col.foodPheromones, FOOD_DECAY);
            }
        }

        // Create offscreen canvas for pheromone rendering (at grid resolution)
        let pheromoneOffscreen = null;
        let pheromoneOffscreenCtx = null;
        let pheromoneImageData = null;

        function initPheromoneOffscreen() {
            pheromoneOffscreen = document.createElement('canvas');
            pheromoneOffscreen.width = gridWidth;
            pheromoneOffscreen.height = gridHeight;
            pheromoneOffscreenCtx = pheromoneOffscreen.getContext('2d');
            pheromoneImageData = pheromoneOffscreenCtx.createImageData(gridWidth, gridHeight);
        }

        function drawPheromones() {
            pheromoneCtx.clearRect(0, 0, width, height);

            if (!showTrails) return;

            // Ensure offscreen canvas exists
            if (!pheromoneOffscreen || pheromoneOffscreen.width !== gridWidth) {
                initPheromoneOffscreen();
            }

            const data = pheromoneImageData.data;

            // Fill ImageData at grid resolution (1 pixel per cell)
            for (let gy = 0; gy < gridHeight; gy++) {
                for (let gx = 0; gx < gridWidth; gx++) {
                    const idx = gy * gridWidth + gx;
                    const pixelIdx = idx * 4;

                    // Accumulate colors from all colonies
                    let r = 0, g = 0, b = 0, totalAlpha = 0;

                    for (const col of colonies) {
                        const home = col.homePheromones[idx];
                        const food = col.foodPheromones[idx];

                        if (home > 1 || food > 1) {
                            const trailColor = col.color.trail;
                            const homeAlpha = Math.min(home / 100, 1) * 0.5;
                            const foodAlpha = Math.min(food / 100, 1) * 0.6;
                            const alpha = homeAlpha + foodAlpha;

                            // Blend this colony's trail color
                            r += trailColor[0] * alpha;
                            g += trailColor[1] * alpha;
                            b += trailColor[2] * alpha;
                            totalAlpha += alpha;
                        }
                    }

                    if (totalAlpha > 0.01) {
                        // Normalize and clamp colors
                        data[pixelIdx] = Math.min(255, Math.floor(r / Math.max(totalAlpha, 1)));
                        data[pixelIdx + 1] = Math.min(255, Math.floor(g / Math.max(totalAlpha, 1)));
                        data[pixelIdx + 2] = Math.min(255, Math.floor(b / Math.max(totalAlpha, 1)));
                        data[pixelIdx + 3] = Math.floor(Math.min(totalAlpha * 0.6, 0.85) * 255);
                    } else {
                        data[pixelIdx] = 0;
                        data[pixelIdx + 1] = 0;
                        data[pixelIdx + 2] = 0;
                        data[pixelIdx + 3] = 0;
                    }
                }
            }

            // Put ImageData to offscreen canvas
            pheromoneOffscreenCtx.putImageData(pheromoneImageData, 0, 0);

            // Scale up to full canvas size (no smoothing for pixelated look)
            pheromoneCtx.imageSmoothingEnabled = false;
            pheromoneCtx.drawImage(pheromoneOffscreen, 0, 0, width, height);
        }

        function drawColonyHill(col) {
            const hillRadius = col.radius * 1.8;
            const colColor = col.color;

            // Outer dirt mound - multiple layers for 3D effect
            for (let i = 5; i >= 0; i--) {
                const layerRadius = hillRadius * (0.5 + i * 0.1);
                const layerOffset = i * 2;

                const gradient = antCtx.createRadialGradient(
                    col.x, col.y - layerOffset, 0,
                    col.x, col.y - layerOffset, layerRadius
                );

                // Use colony color tint for multi-colony mode
                const brightness = 0.6 + i * 0.05;
                if (gameMode === 'multi') {
                    // Parse colony color and apply
                    const tc = col.color.trail;
                    gradient.addColorStop(0, `rgba(${Math.floor(tc[0] * brightness)}, ${Math.floor(tc[1] * brightness * 0.8)}, ${Math.floor(tc[2] * brightness * 0.6)}, ${0.9 - i * 0.1})`);
                    gradient.addColorStop(0.6, `rgba(${Math.floor(tc[0] * brightness * 0.7)}, ${Math.floor(tc[1] * brightness * 0.5)}, ${Math.floor(tc[2] * brightness * 0.3)}, ${0.7 - i * 0.1})`);
                } else {
                    gradient.addColorStop(0, `rgba(${Math.floor(180 * brightness)}, ${Math.floor(140 * brightness)}, ${Math.floor(100 * brightness)}, ${0.9 - i * 0.1})`);
                    gradient.addColorStop(0.6, `rgba(${Math.floor(140 * brightness)}, ${Math.floor(100 * brightness)}, ${Math.floor(70 * brightness)}, ${0.7 - i * 0.1})`);
                }
                gradient.addColorStop(1, `rgba(100, 70, 50, 0)`);

                antCtx.fillStyle = gradient;
                antCtx.beginPath();
                antCtx.arc(col.x, col.y - layerOffset, layerRadius, 0, Math.PI * 2);
                antCtx.fill();
            }

            // Add dirt texture/granules on the mound
            for (let granule of col.granules) {
                const gb = granule.brightness;
                const tc = col.color.trail;
                if (gameMode === 'multi') {
                    antCtx.fillStyle = `rgba(${Math.floor(tc[0] * gb)}, ${Math.floor(tc[1] * gb * 0.7)}, ${Math.floor(tc[2] * gb * 0.5)}, 0.5)`;
                } else {
                    antCtx.fillStyle = `rgba(${100 + Math.floor(gb * 60)}, ${70 + Math.floor(gb * 40)}, ${40 + Math.floor(gb * 30)}, 0.5)`;
                }
                antCtx.beginPath();
                antCtx.arc(col.x + granule.x, col.y + granule.y, granule.size, 0, Math.PI * 2);
                antCtx.fill();
            }

            // Dark entrance hole
            const holeGradient = antCtx.createRadialGradient(
                col.x, col.y, 0,
                col.x, col.y, col.radius * 0.6
            );
            holeGradient.addColorStop(0, 'rgba(20, 15, 10, 1)');
            holeGradient.addColorStop(0.5, 'rgba(40, 30, 20, 0.95)');
            holeGradient.addColorStop(0.8, 'rgba(60, 45, 30, 0.8)');
            holeGradient.addColorStop(1, 'rgba(80, 60, 40, 0)');

            antCtx.fillStyle = holeGradient;
            antCtx.beginPath();
            antCtx.ellipse(col.x, col.y, col.radius * 0.6, col.radius * 0.45, 0, 0, Math.PI * 2);
            antCtx.fill();

            // Hole rim with colony color
            if (gameMode === 'multi') {
                antCtx.strokeStyle = col.color.main;
            } else {
                antCtx.strokeStyle = 'rgba(120, 90, 60, 0.6)';
            }
            antCtx.lineWidth = 2;
            antCtx.beginPath();
            antCtx.ellipse(col.x, col.y, col.radius * 0.6, col.radius * 0.45, 0, 0, Math.PI * 2);
            antCtx.stroke();
        }

        function drawAnts() {
            antCtx.clearRect(0, 0, width, height);

            // Draw all colonies
            for (const col of colonies) {
                drawColonyHill(col);
            }

            // Draw food sources with polygon shapes
            for (let food of foods) {
                if (food.amount > 0) {
                    const scale = 0.4 + (food.amount / food.maxAmount) * 0.6;
                    
                    antCtx.save();
                    antCtx.translate(food.x, food.y);
                    antCtx.rotate(food.rotation);
                    antCtx.scale(scale, scale);
                    
                    // Glow effect
                    const glowGradient = antCtx.createRadialGradient(0, 0, 0, 0, 0, food.radius * 1.5);
                    glowGradient.addColorStop(0, food.color + '40');
                    glowGradient.addColorStop(1, food.color + '00');
                    antCtx.fillStyle = glowGradient;
                    antCtx.beginPath();
                    antCtx.arc(0, 0, food.radius * 1.5, 0, Math.PI * 2);
                    antCtx.fill();
                    
                    // Main polygon shape
                    antCtx.fillStyle = food.color;
                    antCtx.beginPath();
                    antCtx.moveTo(food.vertices[0].x, food.vertices[0].y);
                    for (let i = 1; i < food.vertices.length; i++) {
                        antCtx.lineTo(food.vertices[i].x, food.vertices[i].y);
                    }
                    antCtx.closePath();
                    antCtx.fill();
                    
                    // Highlight
                    antCtx.fillStyle = food.highlight;
                    antCtx.beginPath();
                    const hx = food.vertices[0].x * 0.3;
                    const hy = food.vertices[0].y * 0.3 - 2;
                    antCtx.arc(hx, hy, food.radius * 0.25, 0, Math.PI * 2);
                    antCtx.fill();
                    
                    // Outline
                    antCtx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                    antCtx.lineWidth = 1;
                    antCtx.beginPath();
                    antCtx.moveTo(food.vertices[0].x, food.vertices[0].y);
                    for (let i = 1; i < food.vertices.length; i++) {
                        antCtx.lineTo(food.vertices[i].x, food.vertices[i].y);
                    }
                    antCtx.closePath();
                    antCtx.stroke();
                    
                    antCtx.restore();
                }
            }

            // Draw ants
            for (let ant of ants) {
                ant.draw(antCtx);
            }
        }

        function updateStats() {
            document.getElementById('fps-counter').textContent = currentFps;
            document.getElementById('ant-count').textContent = ants.length;
            document.getElementById('food-sources').textContent = foods.filter(f => f.amount > 0).length;

            if (gameMode === 'multi') {
                // Show total food across all colonies
                const totalFood = colonies.reduce((sum, c) => sum + c.foodStored, 0);
                document.getElementById('food-collected').textContent = totalFood;
                document.getElementById('colony-size').textContent = colonies.length + ' colonies';
            } else {
                document.getElementById('food-collected').textContent = colony.foodStored;
                document.getElementById('colony-size').textContent = Math.floor(1 + colony.foodStored / 50);
            }
        }

        function update() {
            for (let i = 0; i < simulationSpeed; i++) {
                // Update ants
                for (let ant of ants) {
                    ant.update();
                }

                // Remove depleted food
                foods = foods.filter(f => f.amount > 0);

                // Manage food count based on slider
                while (foods.length < targetFoodCount) {
                    spawnRandomFood();
                }
                while (foods.length > targetFoodCount) {
                    foods.pop();
                }

                // Adjust ant count - distribute evenly across colonies
                while (ants.length < targetAntCount) {
                    // Find colony with fewest ants and add there
                    const antCounts = colonies.map((_, idx) =>
                        ants.filter(a => a.colonyId === idx).length
                    );
                    const minIdx = antCounts.indexOf(Math.min(...antCounts));
                    const col = colonies[minIdx];
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * col.radius;
                    ants.push(new Ant(
                        col.x + Math.cos(angle) * dist,
                        col.y + Math.sin(angle) * dist,
                        minIdx
                    ));
                }
                while (ants.length > targetAntCount) {
                    // Find colony with most ants and remove from there
                    const antCounts = colonies.map((_, idx) =>
                        ants.filter(a => a.colonyId === idx).length
                    );
                    const maxIdx = antCounts.indexOf(Math.max(...antCounts));
                    // Find and remove an ant from that colony
                    const removeIdx = ants.findIndex(a => a.colonyId === maxIdx);
                    if (removeIdx !== -1) {
                        ants.splice(removeIdx, 1);
                    } else {
                        ants.pop(); // Fallback
                    }
                }
            }

            // Update pheromones ONCE per frame (not per simulation tick)
            updatePheromones();
        }

        function render() {
            drawPheromones();
            drawAnts();
            updateStats();
        }

        function gameLoop() {
            // FPS calculation
            frameCount++;
            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                currentFps = frameCount;
                frameCount = 0;
                lastFpsTime = now;
            }

            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        // Helper to convert screen coordinates to canvas coordinates (handles browser zoom)
        function screenToCanvas(clientX, clientY) {
            const rect = antCanvas.getBoundingClientRect();
            // Scale by ratio of internal canvas size to displayed size
            const scaleX = antCanvas.width / rect.width;
            const scaleY = antCanvas.height / rect.height;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        // Click to add food
        antCanvas.addEventListener('click', (e) => {
            const pos = screenToCanvas(e.clientX, e.clientY);
            createFood(pos.x, pos.y);
        });

        // Touch support for mobile
        antCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const pos = screenToCanvas(touch.clientX, touch.clientY);
            createFood(pos.x, pos.y);
        });

        document.getElementById('ant-slider').addEventListener('input', (e) => {
            targetAntCount = parseInt(e.target.value);
        });

        document.getElementById('speed-slider').addEventListener('input', (e) => {
            simulationSpeed = parseInt(e.target.value);
        });

        document.getElementById('food-slider').addEventListener('input', (e) => {
            targetFoodCount = parseInt(e.target.value);
        });

        document.getElementById('toggle-trails').addEventListener('click', (e) => {
            showTrails = !showTrails;
            e.target.textContent = showTrails ? 'On' : 'Off';
            e.target.classList.toggle('active', showTrails);
        });

        document.getElementById('toggle-style').addEventListener('click', (e) => {
            antStyle = antStyle === 'classic' ? 'detailed' : 'classic';
            e.target.textContent = antStyle === 'classic' ? 'Ant' : 'Termite';
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            // Clear pheromones for all colonies
            for (const col of colonies) {
                col.homePheromones.fill(0);
                col.foodPheromones.fill(0);
            }
            init();
        });

        let gameStarted = false;

        window.addEventListener('resize', () => {
            if (!gameStarted) return; // Don't resize before game starts

            // Detect if this is a browser zoom change (devicePixelRatio changed)
            const currentRatio = window.devicePixelRatio;
            if (currentRatio !== lastDevicePixelRatio) {
                // Browser zoom changed - don't resize canvas, just update ratio
                lastDevicePixelRatio = currentRatio;
                return;  // Skip canvas resize, let browser handle zoom scaling
            }
            // Actual window resize - preserve pheromone state
            resize(true);
        });

        // Menu handling
        const menuScreen = document.getElementById('menu-screen');
        const singleModeBtn = document.getElementById('single-mode-btn');
        const multiModeBtn = document.getElementById('multi-mode-btn');
        const colonySelector = document.getElementById('colony-selector');
        const countBtns = document.querySelectorAll('.count-btn');
        const startBtn = document.getElementById('start-btn');

        singleModeBtn.addEventListener('click', () => {
            gameMode = 'single';
            singleModeBtn.classList.add('active');
            multiModeBtn.classList.remove('active');
            colonySelector.classList.add('hidden');
        });

        multiModeBtn.addEventListener('click', () => {
            gameMode = 'multi';
            multiModeBtn.classList.add('active');
            singleModeBtn.classList.remove('active');
            colonySelector.classList.remove('hidden');
        });

        countBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                countBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                colonyCount = parseInt(btn.dataset.count);
            });
        });

        startBtn.addEventListener('click', startGame);

        function startGame() {
            // Hide menu
            menuScreen.classList.add('hidden');

            // Show game elements
            document.getElementById('game-header').classList.remove('hidden');
            document.getElementById('game-container').classList.remove('hidden');
            document.getElementById('stats').classList.remove('hidden');
            document.getElementById('legend').classList.remove('hidden');
            document.getElementById('instructions').classList.remove('hidden');
            document.getElementById('controls').classList.remove('hidden');

            // Initialize and start
            gameStarted = true;
            init();
            enableZoomNavigation();
            gameLoop();
        }

        // After init, lock in canvas dimensions to enable zoom navigation
        function enableZoomNavigation() {
            const wrapper = document.getElementById('canvas-wrapper');
            const container = document.getElementById('game-container');

            // Lock wrapper to current canvas size
            wrapper.style.width = width + 'px';
            wrapper.style.height = height + 'px';
            wrapper.style.flexShrink = '0';

            // Allow container to overflow
            container.style.overflow = 'visible';
            container.style.minWidth = width + 'px';
            container.style.minHeight = height + 'px';
        }
    </script>
</body>
</html>
